# 网格放置规则系统设计文档

## Context

当前微信小程序使用分层架构（base_layer 用于结构元素，furniture_layer 用于家具元素），但缺乏统一的放置规则验证系统。用户可以在不合理的位置放置元素，导致视觉冲突和逻辑错误。

## Goals / Non-Goals

**Goals:**
- 实现严格的网格单元独占性规则
- 确保结构元素和家具元素互斥
- 限制家具只能放置在房间内部
- 提供统一的元素覆盖机制
- 保证多格元素的原子化操作
- 通过属性测试验证系统正确性

**Non-Goals:**
- 不改变现有数据结构
- 不实现撤销/重做功能（未来可添加）
- 不处理元素动画或过渡效果

## Decisions

### 决策 1: 集中式验证层架构

**选择**: 实现独立的 GridPlacementEngine 作为 UI 层和数据层之间的验证层

**理由**:
- 所有放置操作通过统一入口，确保规则一致性
- 便于测试和维护
- 不破坏现有代码结构

**备选方案**:
- 在每个 UI 处理器中分散验证逻辑 → 难以维护，容易遗漏
- 修改数据层添加验证 → 侵入性强，破坏现有架构

### 决策 2: 使用 fast-check 进行属性测试

**选择**: 使用 fast-check 库实现属性测试，每个测试至少 100 次迭代

**理由**:
- 属性测试能发现边界情况和意外组合
- fast-check 是 JavaScript 生态中成熟的属性测试库
- 补充单元测试，提供更全面的覆盖

**备选方案**:
- 仅使用单元测试 → 难以覆盖所有边界情况
- 手动编写大量测试用例 → 工作量大，维护困难

### 决策 3: 组件化设计

**选择**: 将系统拆分为 PlacementValidator、OverwriteManager、GridStateManager、MultiCellHandler 四个独立组件

**理由**:
- 单一职责原则，每个组件专注一个功能
- 便于独立测试和复用
- 降低复杂度，提高可维护性

## Architecture

```
UI Layer (Touch Handlers)
    ↓
GridPlacementEngine (Main Entry)
    ↓
┌─────────────────┬──────────────────┬──────────────────┬─────────────────┐
│ PlacementValidator│ OverwriteManager│ GridStateManager│ MultiCellHandler│
└─────────────────┴──────────────────┴──────────────────┴─────────────────┘
    ↓
Data Layer (designData structure)
    ↓
Rendering Layer (Canvas drawing)
```

## Risks / Trade-offs

**风险 1: 性能影响**
- 每次放置操作需要额外验证
- **缓解**: 优化状态查询，使用高效数据结构（Map/Set）

**风险 2: 与现有代码集成复杂度**
- 需要修改多个现有方法
- **缓解**: 渐进式集成，保持向后兼容，充分测试

**权衡**: 增加代码复杂度 vs 提升用户体验和系统可靠性
- **选择**: 接受适度的复杂度增加，换取更好的用户体验

## Migration Plan

1. **阶段 1**: 实现核心引擎和组件（不影响现有功能）
2. **阶段 2**: 在测试环境集成新系统
3. **阶段 3**: 逐步替换现有放置逻辑
4. **阶段 4**: 完整测试和性能优化

**回滚计划**:
- 新系统作为独立模块，可通过配置开关禁用
- 保留原有放置逻辑作为备份

## Open Questions

- 房间内部检测算法的具体实现（射线法 vs 边界框法）？
- 是否需要支持部分覆盖模式（例如小家具可以和墙共存）？
- 错误提示的具体文案和交互方式？
